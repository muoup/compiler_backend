# Inefficiencies
A small catalogue of issues that do not cause issues,
but lead to the generation of less optimized code.
Hopefully over time some or most of these will be fixed.

## ASM Gen
### Excessive Register Saving
Consider the abridged version of the 'fib' routine,
generated by the compiler with the input "../examples/fibonnaci.ir".
```asm
fib:
.__stacksave:
    push    rbx
    push    rcx
    push    rdx
    push    rsi
.entry:
    cmp     edi, 1
    jbe     .base_case
    jmp     .recursive_case
.base_case:
    mov     eax, edi
    pop     rsi
    pop     rdx
    pop     rcx
    pop     rbx
    ret     
.recursive_case:
    ... ; rsi, rdx, rcx, rbx are modified
    pop     rsi       
    pop     rdx
    pop     rcx
    pop     rbx
    ret     
```

In the base case, no registers will have been mutated, making the
subsequent pop instructions, along with the push instructions at the
start of the routine entirely redundant and wasteful.

On the contrary, in the recursive case, all four registers will have been modified,
so the push and pop instructions would have been necessary.

The solution to this problem intuitively would be to move the __stacksave logic to start
when .recursive case is called, as such:

```asm
fib:
.__stacksave:
.entry:
    cmp     edi, 1
    jbe     .base_case
    jmp     .recursive_case
.base_case:
    mov     eax, edi
    ret     
.recursive_case:
.resursive_case.__stacksave:
    push    rbx
    push    rcx
    push    rdx
    push    rsi
    ... ; rsi, rdx, rcx, rbx are modified
    pop     rsi
    pop     rdx
    pop     rcx
    pop     rbx
    ret     
```

Implementing this would require more sophisticated control flow analysis,
determining where subroutines can be called from, and isolating sections of the
routine that can have their own __stacksave logic as once entered, they can only
be exited by returning.

In essence, the solution becomes an issue of graph theory, which may be
more effort than it is worth, but would make for a good exercise in optimization.